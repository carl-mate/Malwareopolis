package com.mygdx.game;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;

public class BaseArtillery extends DragAndDropActor {
    private MapArea mapArea;
    protected Animation<TextureRegion> walkAnimation;

    public BaseArtillery(float x, float y, Stage s) {
        super(x, y, s);
    }

    protected void loadAnimationFromFiles(String[] filenames){
        walkAnimation = loadAnimationFromFiles(filenames, 0.1f, true);
    }

    public void setMapArea(MapArea mapArea) {
        this.mapArea = mapArea;
    }

    public MapArea getMapArea()
    {  return mapArea;  }

    public void clearMapArea()
    {  mapArea = null;  }

    public boolean hasMapArea()
    {  return mapArea != null;  }

    // override method from DragAndDropActor class
    public void onDragStart()
    {
        if ( hasMapArea() )
        {
            MapArea mapArea = getMapArea();
            mapArea.setTargetable(true);
            clearMapArea();
        }
    }

    // override method from DragAndDropActor class
    public void onDrop() {
        if ( hasDropTarget() ) {
            MapArea mapArea = (MapArea)getDropTarget();
            moveToActor(mapArea);
            setMapArea(mapArea);
            mapArea.setTargetable(false);
            setCol(mapArea.getCol());
            setRow(mapArea.getRow());
            setDraggable(false);
        }
    }

    @Override
    public void findDropTarget(DragAndDropActor self) {
        // keep track of distance to closest object
        float closestDistance = Float.MAX_VALUE;
        MapArea target = null;
        for ( BaseActor actor : BaseActor.getList(self.getStage(), "com.mygdx.game.MapArea") ) {
            if ( self.overlaps(actor) )
            {
                float currentDistance =
                        Vector2.dst(self.getCenterX(),self.getCenterY(),
                                actor.getCenterX(),actor.getCenterY());

                // check if this target is even closer
                if (currentDistance < closestDistance)
                {
                    target = (MapArea) actor;
                    closestDistance = currentDistance;
                }
            }
        }
        if (target != null){
            if (target.isTargetable()) {
//                System.out.println(target.getRow() + "|" + target.getCol());
                target.showSuccessTexture();
                self.setDropTarget(target);
                // return object to original size when dropped by player
                self.addAction( Actions.scaleTo(1.00f, 1.00f, 0.25f) );
            } else {
//                errorPlantSound.play(0.3f);
                target.showFailureTexture();
                moveToSlot();
                self.addAction( Actions.scaleTo(0.8f, 0.6f, 0.25f) );
            }
        } else {
            moveToSlot();
            self.addAction( Actions.scaleTo(0.8f, 0.6f, 0.25f) );
        }
    }

    public void hitByZombie (float damage) {
        health -= damage;
    }

    @Override
    public void setDropTarget(DropTargetActor a) {
        super.setDropTarget(a);
    }

    @Override
    public boolean isAlive() {
        return (!hasMapArea() && super.isAlive()) ||
                (super.isAlive() && hasMapArea())||
                (super.isAlive() && hasMapArea());
    }
}
