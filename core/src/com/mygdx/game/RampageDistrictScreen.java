package com.mygdx.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.Touchable;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.Cell;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.TextButton;
import com.badlogic.gdx.scenes.scene2d.utils.TextureRegionDrawable;
import com.badlogic.gdx.utils.Align;

import java.io.IOException;
import java.util.Queue;
import java.util.Random;

public class RampageDistrictScreen extends BaseScreen{

    private float leftWidthOffset;
    private float lowerHeightOffset;
    private int colNum;
    private int rowNum;
    private float areaWidth;
    private float areaHeight;

    private BaseActor artilleryTable;


    private BaseActor labelActor;
    private Label displayLabel;

    private boolean gameOver = false;
    private boolean noMinions = false;
    private Queue<String> minionQueue;

    private BaseActor slotButton;

    private float elapsedTime;
    private Random random = new Random();
    private String[] minionNames = {"adware", "worm", "trojan", "spyware", "ransomware", "boss"};
    private MinionScheduler minionScheduler;

    public RampageDistrictScreen() throws IOException {

    }

    private void initArtillerySelectionTable(){
        uiTable.padRight(300);
        uiTable.padLeft(labelActor.getWidth() + 5);
        slotButton = new BaseActor(0, 0, mainStage);
        slotButton.loadTexture("slot.png");
        slotButton.setPosition(504, 511);

        addButtonToTable("ariva-power-wasp_50");
        addButtonToTable("tese-freeze_175");
        addButtonToTable("torton-blast_100");
        addButtonToTable("tsava-defense_50");
        addButtonToTable("skyskraper-ultrablast_200");


        uiTable.add().expandY();
    }

    private void lockAllButtons(boolean lock, int yellowCapsule) {
        try {
            Class buttonClass = Class.forName("com.badlogic.gdx.scenes.scene2d.ui.TextButton");
            for (Cell cell : uiTable.getCells()) {
                Actor button = cell.getActor();
                if ( buttonClass.isInstance(button) )
                    if (lock){
                        if (!((CardButton) button).getButtonRealText().contains("Pause")){
                            ((CardButton) button).setDisabled(true);
                            button.setTouchable(Touchable.disabled);
                        }
                    } else {
                        int collectYellowCapsuleAmount = Integer.valueOf(displayLabel.getText().toString());
                        if (collectYellowCapsuleAmount >= ((CardButton) button).getYellowCapsuleDemand())
                            {
                                ((CardButton) button).setDisabled(false);
                                button.setTouchable(Touchable.enabled);
                            }
                    }
            }
            if (lock) {
                displayLabel.setText(String.valueOf(
                        Integer.valueOf(displayLabel.getText().toString()) - yellowCapsule) );
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    private void addButtonToTable(String buttonName){
        final CardButton tableButton = new CardButton(buttonName);

        tableButton.addListener(new InputListener(){
            int yellowCapsuleDecrease = tableButton.getYellowCapsuleDemand();
            String name = tableButton.getButtonRealText();
            @Override
            public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
                BaseArtillery baseArtillery = null;
                if (name.equals("ariva-power-wasp")){
                    baseArtillery = new ArivaPowerWasp(Float.MAX_VALUE, Float.MAX_VALUE, mainStage);
                } else if (name.equals("tese-freeze")) {
                    baseArtillery = new TeseFreeze(Float.MAX_VALUE, Float.MAX_VALUE, mainStage, "tese-freeze");
                } else if (name.equals("torton-blast")) {
                    baseArtillery = new TortonBlast(Float.MAX_VALUE, Float.MAX_VALUE, mainStage);
                } else if (name.equals("tsava-defense")) {
                    baseArtillery = new TsavaDefense(Float.MAX_VALUE, Float.MAX_VALUE, mainStage);
                } else if (name.equals("skyskraper-ultrablast")){
                    baseArtillery = new SkyskraperUltrablast(Float.MAX_VALUE, Float.MAX_VALUE, mainStage);
                }

                baseArtillery.setScale(0.8f, 0.6f);
                baseArtillery.centerAtActor(slotButton);
                lockAllButtons(true, yellowCapsuleDecrease);
                return false;
        }
    });
        uiTable.add(tableButton).expandX().top();
}

    @Override
    protected void initialize() {
        minionScheduler = new MinionScheduler();
        minionQueue = minionScheduler.generateMinionQueue();
        colNum = 9;
        rowNum = 5;

        leftWidthOffset = 44;
        lowerHeightOffset = 27;

        areaHeight = 504.0f / rowNum;
        areaWidth = 704.0f / colNum;

        BaseActor background = new BaseActor(0, 0, mainStage);
        background.loadTexture("rampage-district-bg.png");

        for(int row = 0; row < rowNum; row++){
            for(int col = 0; col < colNum; col++){
                int leftCornerX = (int) (leftWidthOffset + col * areaWidth);
                int leftCornerY = (int) (lowerHeightOffset + row * areaHeight);
                MapArea mapArea = new MapArea(leftCornerX, leftCornerY, mainStage);
                mapArea.setSize(areaWidth, areaHeight);
                mapArea.setBoundaryRectangle();
                mapArea.setRow(row);
                mapArea.setCol(col);
            }
        }


        initYellowCapsuleLabel();
        initArtillerySelectionTable();
        lockAllButtons(false, 0);
    }

    private void initYellowCapsuleLabel(){
        labelActor = new BaseActor(0, 0, mainStage);
        labelActor.loadTexture("SunBack.png");
        labelActor.setPosition(0, 600 - labelActor.getHeight());
        labelActor.setBoundaryRectangle();

        displayLabel = new Label("5000", BaseGame.labelStyleBlack);
        mainStage.addActor(displayLabel);
        labelActor.addActor(displayLabel);
        displayLabel.setPosition((labelActor.getWidth() - displayLabel.getWidth()) / 2,  18);
        displayLabel.setVisible(true);

        lockAllButtons(true, 0);
        lockAllButtons(false,0);
    }

    private void killActors(){
        boolean noWaitingArtillery = true;
        for (BaseActor actor: BaseActor.getList(mainStage, "com.mygdx.game.BaseActor")) {
            try {
                if (Class.forName("com.mygdx.game.BaseArtillery").isInstance(actor) && !((BaseArtillery) actor).hasDropTarget()) {
                    if (actor.checkOutSideScreen()){
                        actor.addAction(Actions.after(
                                Actions.sequence(Actions.fadeOut(0.1f), Actions.removeActor())));
                    }
                    else
                        noWaitingArtillery = false;
                } else if (Class.forName("com.mygdx.game.YellowEnergyCapsule").isInstance(actor) && actor.overlaps(labelActor)) {
                    int tempSunlightAmount = Integer.valueOf(displayLabel.getText().toString());
                    tempSunlightAmount += ((YellowEnergyCapsule) actor).getAddAmount();
                    displayLabel.setText(String.valueOf(tempSunlightAmount));
                    ((YellowEnergyCapsule) actor).setAddAmount(0);
                } else if (Class.forName("com.mygdx.game.BaseMinion").isInstance(actor)) {
                    if (actor.getX() < 100) {
                        gameOver = true;
                        break;
                    }
                }

            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }

            if (! actor.isAlive()) {
                try {
                    if (Class.forName("com.mygdx.game.BaseArtillery").isInstance(actor)){
                        MapArea mapArea = (MapArea) ((BaseArtillery) actor).getDropTarget();
                        mapArea.setTargetable(true);
                    }

                    if (noMinions) {
                        if (Class.forName("com.mygdx.game.BaseMinion").isInstance(actor))
                            actor.setOpacity(0.0f);
                    }
                }
                catch (ClassNotFoundException e) {
                    e.printStackTrace();
                }

                actor.addAction(Actions.after(
                        Actions.sequence(Actions.fadeOut(0.1f), Actions.removeActor())));

            }
        }

        if(noWaitingArtillery) {
            lockAllButtons(false, 0);
        }
    }

    private void minionPlacer(){
        String nextMinion = minionQueue.peek();

        if(nextMinion == null){
            noMinions = true;
            return;
        }
        float nextComingTime = Float.valueOf(nextMinion.split("@")[1]);

        if(elapsedTime < nextComingTime) return;
        minionQueue.poll();
        float x = leftWidthOffset + (colNum + 0.5f) * areaWidth;
        int minionIndex = Integer.valueOf(nextMinion.split("@")[0]);

        int row;
        if(minionIndex != 4){
            int[] rowSamples = {0,1,3,4};
            row = rowSamples[random.nextInt(4)];
        } else{
            int[] rowSamples = {2,3};
            row = rowSamples[random.nextInt(2)];
        }
        float y = lowerHeightOffset + row * areaHeight;

        BaseMinion minion = minionScheduler.makeMinion(minionNames[minionIndex - 1], mainStage);
        minion.setPosition(x, y);
        minion.setRow(row);
    }

    @Override
    public void update(float dt) {
        elapsedTime += dt;
        minionPlacer();
        killActors();
    }
}
