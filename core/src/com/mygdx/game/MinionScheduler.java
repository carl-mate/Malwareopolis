package com.mygdx.game;

import com.badlogic.gdx.scenes.scene2d.Stage;

import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;

public class MinionScheduler {
    private float shortInterval = 3.0f;
    private float longInterval = 5.0f;
    private float minionInterval = 2.0f;

    public Queue<String> generateMinionQueue(){
        Queue<String> minionQueue = new LinkedList<>();

//        String rawSequence = "0,0,1,1\n" +
//                          "1,1,2\n" +
//                          "1,2,5\n" +
//                          "1,2,2,5,5\n" +
//                          "2,3,4,5,5,5\n" +
//                          "2,3,4,6,6,6";

         String rawSequence = "0,0,1,1\n" +
                          "1,1,2\n" +
                          "1,2,5\n" +
                          "1,2,2,5,5\n" +
                          "2,3,4,6,6,6";


        String[] lineArray = rawSequence.split("\n");
        float[] intervalTimeArray = {0,0,0,0,0};
        int lineCount = -1;

        // 15 seconds for preparation
//        float elapsedTime = 15.0f;
        float elapsedTime = 0;
        for(String line: lineArray){
            lineCount += 1;
            if(lineCount == 0){
                String[] intervalStringArray = line.split(",");
                intervalTimeArray = new float[intervalStringArray.length];
                for(int i = 0; i < intervalStringArray.length; i++){
                    intervalTimeArray[i] = intervalStringArray[i].equals("0") ? shortInterval : longInterval;
                }
            } else{
                elapsedTime += intervalTimeArray[lineCount-1];
                LinkedList<String> singleLayerMinions = new LinkedList<>();
                String[] minionIndices = line.split(",");
                for(String minionIndex: minionIndices){
                    if(minionIndex.contains("*")){
                        String[] minionWithCount = minionIndex.split("\\*");
                        for(int i = 0; i < Integer.valueOf(minionWithCount[1]); i++){
                            singleLayerMinions.add(minionWithCount[0]);
                        }
                    } else{
                        singleLayerMinions.add(minionIndex);
                    }
                }
                Collections.shuffle(singleLayerMinions);

                for(String minionIndex: singleLayerMinions){
                    minionQueue.offer(String.format("%s@%.2f", minionIndex, elapsedTime));
                    elapsedTime += minionInterval;
                }
            }
        }
        return minionQueue;
    }

    public BaseMinion makeMinion(String minionName, Stage s){
        BaseMinion minion = null;
        if(minionName.equals("adware")){
            minion = new MalwareMinion(Float.MAX_VALUE, Float.MAX_VALUE, s, minionName);
            minion.setMinionSpeed(20.0f);
        } else if(minionName.equals("worm")){
            minion = new MalwareMinion(Float.MAX_VALUE, Float.MAX_VALUE, s, minionName);
            minion.setMinionSpeed(15.0f);
        } else if(minionName.equals("trojan")){
            minion = new MalwareMinion(Float.MAX_VALUE, Float.MAX_VALUE, s, minionName);
            minion.setMinionSpeed(25.0f);
        } else if(minionName.equals("spyware")){
            minion = new MalwareMinion(Float.MAX_VALUE, Float.MAX_VALUE, s, minionName);
            minion.setMinionSpeed(25.0f);
        } else if(minionName.equals("ransomware")){
            minion = new MalwareMinion(Float.MAX_VALUE, Float.MAX_VALUE, s, minionName);
            minion.setMinionSpeed(25.0f);
        } else if(minionName.equals("boss")){
            minion = new MalwareMinion(Float.MAX_VALUE, Float.MAX_VALUE, s, minionName);
            minion.setMinionSpeed(10.0f);
            minion.setDamage(200);
        }
        return minion;
    }
}
